{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["client","SwiftypeAppSearch","hostIdentifier","searchKey","engineName","App","state","searchTerm","results","category1","category2","category3","search","_callee","newFilters","promises","updatedFilters","_ref2","_ref3","category1Facets","category2Facets","category3Facets","facets","regenerator_default","a","wrap","_context","prev","next","Object","objectSpread","_this","toConsumableArray","concat","filters","all","getFiltersArray","type","getCategory1Facets","getCategory2Facets","getCategory3Facets","Promise","sent","slicedToArray","info","abrupt","stop","this","_callee2","_context2","page","size","_callee3","_context3","_callee4","_context4","onSubmit","e","preventDefault","then","setState","onChange","target","value","handleClickCategory1","handleClickCategory2","handleClickCategory3","arr","_this2","_this3","react_default","createElement","Layout","header","SearchBox","sideContent","data","map","category1Facet","key","className","onClick","count","category2Facet","category3Facet","bodyContent","result","Result","getRaw","fields","title","onClickLink","Component","Boolean","window","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"qVAOIA,SAASC,eAA+B,CAC1CC,eAAgB,cAChBC,UAAW,kCACXC,WAAY,0BAmUCC,6MA/TbC,MAAQ,CACNC,WAAY,GACZC,QAAS,KACTC,UAAW,GACXC,UAAW,GACXC,UAAW,MA0BbC,6CAAS,SAAAC,EAAMC,GAAN,IAAAC,EAAAC,EAAAC,EAAAC,EAAAV,EAAAW,EAAAC,EAAAC,EAAAC,EAAA,OAAAC,EAAAC,EAAAC,KAAA,SAAAC,GAAA,cAAAA,EAAAC,KAAAD,EAAAE,MAAA,cACHb,EAAW,GAETC,EAHCa,OAAAC,EAAA,EAAAD,CAAA,GAGqBE,EAAKzB,MAAUQ,GAE3CC,EAAQc,OAAAG,EAAA,EAAAH,CACHd,GADGkB,OAAA,CAENjC,EAAOY,OAAOmB,EAAKzB,MAAMC,WAAY,CACnC2B,QAAS,CACPC,IAAKJ,EAAKK,gBAAgBpB,IAE5BM,OAAQ,CAGNb,UAAW,CACT,CACE4B,KAAM,UAGV3B,UAAW,CACT,CACE2B,KAAM,UAGV1B,UAAW,CACT,CACE0B,KAAM,eAYZrB,EAAeP,YACjBM,EAAQc,OAAAG,EAAA,EAAAH,CAAOd,GAAPkB,OAAA,CAAiBF,EAAKO,wBAI5BtB,EAAeN,YACjBK,EAAQc,OAAAG,EAAA,EAAAH,CAAOd,GAAPkB,OAAA,CAAiBF,EAAKQ,mBAAmBvB,MAI/CA,EAAeL,YACjBI,EAAQc,OAAAG,EAAA,EAAAH,CAAOd,GAAPkB,OAAA,CAAiBF,EAAKS,mBAAmBxB,MAjD5CU,EAAAE,KAAA,EAyDGa,QAAQN,IAAIpB,GAzDf,cAAAE,EAAAS,EAAAgB,KAAAxB,EAAAW,OAAAc,EAAA,EAAAd,CAAAZ,EAAA,GAqDLT,EArDKU,EAAA,GAsDLC,EAtDKD,EAAA,GAuDLE,EAvDKF,EAAA,GAwDLG,EAxDKH,EAAA,GA2DDI,EA3DCO,OAAAC,EAAA,EAAAD,CAAA,GA4DFV,EACAC,EACAC,GAKLb,EAAQoC,KAAKtB,OAAbO,OAAAC,EAAA,EAAAD,CAAA,GAA2BrB,EAAQoC,KAAKtB,OAAWA,GAnE5CI,EAAAmB,OAAA,SAqEArC,GArEA,yBAAAkB,EAAAoB,SAAAjC,EAAAkC,iEAwETT,wCAAqB,SAAAU,IAAA,IAAAxC,EAAA,OAAAe,EAAAC,EAAAC,KAAA,SAAAwB,GAAA,cAAAA,EAAAtB,KAAAsB,EAAArB,MAAA,cAAAqB,EAAArB,KAAA,EACG5B,EAAOY,OAAOmB,EAAKzB,MAAMC,WAAY,CACzD2C,KAAM,CACJC,KAAM,GAER7B,OAAQ,CACNb,UAAW,CACT,CACE4B,KAAM,aARK,cACb7B,EADayC,EAAAP,KAAAO,EAAAJ,OAAA,SAaZrC,EAAQoC,KAAKtB,QAbD,wBAAA2B,EAAAH,SAAAE,EAAAD,WAgBrBR,yDAAqB,SAAAa,EAAMtC,GAAN,IAAAN,EAAA,OAAAe,EAAAC,EAAAC,KAAA,SAAA4B,GAAA,cAAAA,EAAA1B,KAAA0B,EAAAzB,MAAA,cAAAyB,EAAAzB,KAAA,EACG5B,EAAOY,OAAOmB,EAAKzB,MAAMC,WAAY,CACzD2C,KAAM,CACJC,KAAM,GAERjB,QAAS,CACPC,IAAK,CAAC,CAAE1B,UAAWK,EAAWL,aAEhCa,OAAQ,CACNZ,UAAW,CACT,CACE2B,KAAM,aAXK,cACb7B,EADa6C,EAAAX,KAAAW,EAAAR,OAAA,SAgBZrC,EAAQoC,KAAKtB,QAhBD,wBAAA+B,EAAAP,SAAAM,EAAAL,iEAmBrBP,yDAAqB,SAAAc,EAAMxC,GAAN,IAAAN,EAAA,OAAAe,EAAAC,EAAAC,KAAA,SAAA8B,GAAA,cAAAA,EAAA5B,KAAA4B,EAAA3B,MAAA,cAAA2B,EAAA3B,KAAA,EACG5B,EAAOY,OAAOmB,EAAKzB,MAAMC,WAAY,CACzD2C,KAAM,CACJC,KAAM,GAERjB,QAAS,CACPC,IAAK,CACH,CAAE1B,UAAWK,EAAWL,WACxB,CAAEC,UAAWI,EAAWJ,aAG5BY,OAAQ,CACNX,UAAW,CACT,CACE0B,KAAM,aAdK,cACb7B,EADa+C,EAAAb,KAAAa,EAAAV,OAAA,SAmBZrC,EAAQoC,KAAKtB,QAnBD,wBAAAiC,EAAAT,SAAAQ,EAAAP,iEAsBrBS,SAAW,SAAAC,GACTA,EAAEC,iBAEF3B,EAAKnB,SAAS+C,KAAK,SAAAnD,GACjBuB,EAAK6B,SAAS,CACZpD,iBAKNqD,SAAW,SAAAJ,GACT,IAAMlD,EAAakD,EAAEK,OAAOC,MAC5BhC,EAAK6B,SAAS,CACZrD,kBAIJyD,qBAAuB,SAAAvD,GACrBsB,EAAKnB,OAAO,CAAEH,cAAakD,KAAK,SAAAnD,GAC9BuB,EAAK6B,SAAS,CACZpD,UACAC,YACAC,UAAW,GACXC,UAAW,UAKjBsD,qBAAuB,SAAAvD,GACrBqB,EAAKnB,OAAO,CAAEF,cAAaiD,KAAK,SAAAnD,GAC9BuB,EAAK6B,SAAS,CACZpD,UACAE,YACAC,UAAW,UAKjBuD,qBAAuB,SAAAvD,GACrBoB,EAAKnB,OAAO,CAAED,cAAagD,KAAK,SAAAnD,GAC9BuB,EAAK6B,SAAS,CACZpD,UACAG,gGA/LUuB,GAAS,IACfzB,EAAoCyB,EAApCzB,UAAWC,EAAyBwB,EAAzBxB,UAAWC,EAAcuB,EAAdvB,UAE1BwD,EAAM,GAcV,OAZI1D,IACF0D,EAAG,CAAI,CAAE1D,cAANwB,OAAAJ,OAAAG,EAAA,EAAAH,CAAsBsC,KAGvBzD,IACFyD,EAAG,CAAI,CAAEzD,cAANuB,OAAAJ,OAAAG,EAAA,EAAAH,CAAsBsC,KAGvBxD,IACFwD,EAAG,CAAI,CAAExD,cAANsB,OAAAJ,OAAAG,EAAA,EAAAH,CAAsBsC,KAGpBA,8CAmLW,IAAAC,EAAArB,KAClBA,KAAKnC,SAAS+C,KAAK,SAAAnD,GACjB4D,EAAKR,SAAS,CACZpD,+CAKG,IAAA6D,EAAAtB,KACP,OACEuB,EAAA9C,EAAA+C,cAAA,WACED,EAAA9C,EAAA+C,cAACC,EAAA,EAAD,CACEC,OACEH,EAAA9C,EAAA+C,cAACG,EAAA,EAAD,CACEX,MAAOhB,KAAKzC,MAAMC,WAClBsD,SAAUd,KAAKc,SACfL,SAAUT,KAAKS,WAGnBmB,YACEL,EAAA9C,EAAA+C,cAAA,WACGxB,KAAKzC,MAAME,SACV8D,EAAA9C,EAAA+C,cAAA,WACGxB,KAAKzC,MAAME,QAAQoC,KAAKtB,OAAxB,UAA4C,GAAGsD,KAAKC,IACnD,SAAAC,GAAc,OACZR,EAAA9C,EAAA+C,cAAA,OAAKQ,IAAKD,EAAef,OACvBO,EAAA9C,EAAA+C,cAAA,QACES,UAAU,aACVC,QAAS,SAAAxB,GACPA,EAAEC,iBACFW,EAAKL,qBAAqBc,EAAef,SAG1Ce,EAAef,MAPlB,KAO2Be,EAAeI,MAP1C,KASCb,EAAK/D,MAAMG,YAAcqE,EAAef,OACvCO,EAAA9C,EAAA+C,cAAA,WACGF,EAAK/D,MAAME,QAAQoC,KAAKtB,OAAxB,UAEC,GAAGsD,KAAKC,IAAI,SAAAM,GAAc,OAC1Bb,EAAA9C,EAAA+C,cAAA,OAAKQ,IAAKI,EAAepB,OAAzB,WAEEO,EAAA9C,EAAA+C,cAAA,QACES,UAAU,aACVC,QAAS,SAAAxB,GACPA,EAAEC,iBACFW,EAAKJ,qBACHkB,EAAepB,SAIlBoB,EAAepB,MATlB,KAS2BoB,EAAeD,MAT1C,KAYCb,EAAK/D,MAAMI,YACVyE,EAAepB,OACfO,EAAA9C,EAAA+C,cAAA,WACGF,EAAK/D,MAAME,QAAQoC,KAAKtB,OAAxB,UAEC,GAAGsD,KAAKC,IAAI,SAAAO,GAAc,OAC1Bd,EAAA9C,EAAA+C,cAAA,OAAKQ,IAAKK,EAAerB,OAAzB,mBAEEO,EAAA9C,EAAA+C,cAAA,QACES,UAAU,aACVC,QAAS,SAAAxB,GACPA,EAAEC,iBACFW,EAAKH,qBACHkB,EAAerB,SAIlBqB,EAAerB,MATlB,KAUGqB,EAAeF,MAVlB,kBA2B9BG,YACEf,EAAA9C,EAAA+C,cAAA,WACGxB,KAAKzC,MAAME,SACVuC,KAAKzC,MAAME,QAAQA,QAAQqE,IAAI,SAAAS,GAAM,OACnChB,EAAA9C,EAAA+C,cAACgB,EAAA,EAAD,CACER,IAAKO,EAAOE,OAAO,MACnBC,OAAQ,CACNhF,UAAW6E,EAAOE,OAAO,aACzB9E,UAAW4E,EAAOE,OAAO,aACzB7E,UAAW2E,EAAOE,OAAO,cAE3BE,MAAOJ,EAAOE,OAAO,QACrBG,YAAa,4BArTfC,aCDEC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAO7B,EAAA9C,EAAA+C,cAAC6B,EAAD,MAASC,SAASC,eAAe,SD2H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAM9C,KAAK,SAAA+C,GACjCA,EAAaC","file":"static/js/main.82ccbda3.chunk.js","sourcesContent":["import React, { Component } from \"react\";\nimport { Layout, Result, SearchBox } from \"@elastic/react-search-ui-views\";\nimport \"@elastic/react-search-ui-views/lib/styles/styles.css\";\nimport * as SwiftypeAppSearch from \"swiftype-app-search-javascript\";\n\nimport \"./App.css\";\n\nvar client = SwiftypeAppSearch.createClient({\n  hostIdentifier: \"host-n16af4\",\n  searchKey: \"search-foueoyusuprj187kv7hyfof9\",\n  engineName: \"hierarchichal-facets\"\n});\n\nclass App extends Component {\n  state = {\n    searchTerm: \"\",\n    results: null,\n    category1: \"\",\n    category2: \"\",\n    category3: \"\"\n  };\n\n  /*\n    Converts filters object to array syntax for API\n  */\n  getFiltersArray(filters) {\n    const { category1, category2, category3 } = filters;\n\n    let arr = [];\n\n    if (category1) {\n      arr = [{ category1 }, ...arr];\n    }\n\n    if (category2) {\n      arr = [{ category2 }, ...arr];\n    }\n\n    if (category3) {\n      arr = [{ category3 }, ...arr];\n    }\n\n    return arr;\n  }\n\n  search = async newFilters => {\n    let promises = [];\n\n    const updatedFilters = { ...this.state, ...newFilters };\n\n    promises = [\n      ...promises,\n      client.search(this.state.searchTerm, {\n        filters: {\n          all: this.getFiltersArray(updatedFilters)\n        },\n        facets: {\n          // On each search we perform, we will fetch all of the facets we\n          // need, and simply not show the ones we do not need.\n          category1: [\n            {\n              type: \"value\"\n            }\n          ],\n          category2: [\n            {\n              type: \"value\"\n            }\n          ],\n          category3: [\n            {\n              type: \"value\"\n            }\n          ]\n        }\n      })\n    ];\n\n    // If we've filtered on our first dimension, we won't have\n    // counts for ALL of our 1st level dimensions, we'd only have a count\n    // for the currently selected dimension. We'll do a separate query\n    // to get our first dimension's facet counts, and merge them into the\n    // counts we get back from our search query.\n    if (updatedFilters.category1) {\n      promises = [...promises, this.getCategory1Facets()];\n    }\n\n    // Ditto\n    if (updatedFilters.category2) {\n      promises = [...promises, this.getCategory2Facets(updatedFilters)];\n    }\n\n    // Ditto\n    if (updatedFilters.category3) {\n      promises = [...promises, this.getCategory3Facets(updatedFilters)];\n    }\n\n    const [\n      results,\n      category1Facets,\n      category2Facets,\n      category3Facets\n    ] = await Promise.all(promises);\n\n    const facets = {\n      ...category1Facets,\n      ...category2Facets,\n      ...category3Facets\n    };\n\n    // As mentioned above, we merge all of our individual facet queries back\n    // into our search query results.\n    results.info.facets = { ...results.info.facets, ...facets };\n\n    return results;\n  };\n\n  getCategory1Facets = async () => {\n    const results = await client.search(this.state.searchTerm, {\n      page: {\n        size: 0\n      },\n      facets: {\n        category1: [\n          {\n            type: \"value\"\n          }\n        ]\n      }\n    });\n    return results.info.facets;\n  };\n\n  getCategory2Facets = async newFilters => {\n    const results = await client.search(this.state.searchTerm, {\n      page: {\n        size: 2\n      },\n      filters: {\n        all: [{ category1: newFilters.category1 }]\n      },\n      facets: {\n        category2: [\n          {\n            type: \"value\"\n          }\n        ]\n      }\n    });\n    return results.info.facets;\n  };\n\n  getCategory3Facets = async newFilters => {\n    const results = await client.search(this.state.searchTerm, {\n      page: {\n        size: 0\n      },\n      filters: {\n        all: [\n          { category1: newFilters.category1 },\n          { category2: newFilters.category2 }\n        ]\n      },\n      facets: {\n        category3: [\n          {\n            type: \"value\"\n          }\n        ]\n      }\n    });\n    return results.info.facets;\n  };\n\n  onSubmit = e => {\n    e.preventDefault();\n\n    this.search().then(results => {\n      this.setState({\n        results\n      });\n    });\n  };\n\n  onChange = e => {\n    const searchTerm = e.target.value;\n    this.setState({\n      searchTerm\n    });\n  };\n\n  handleClickCategory1 = category1 => {\n    this.search({ category1 }).then(results => {\n      this.setState({\n        results,\n        category1,\n        category2: \"\",\n        category3: \"\"\n      });\n    });\n  };\n\n  handleClickCategory2 = category2 => {\n    this.search({ category2 }).then(results => {\n      this.setState({\n        results,\n        category2,\n        category3: \"\"\n      });\n    });\n  };\n\n  handleClickCategory3 = category3 => {\n    this.search({ category3 }).then(results => {\n      this.setState({\n        results,\n        category3\n      });\n    });\n  };\n\n  componentDidMount() {\n    this.search().then(results => {\n      this.setState({\n        results\n      });\n    });\n  }\n\n  render() {\n    return (\n      <div>\n        <Layout\n          header={\n            <SearchBox\n              value={this.state.searchTerm}\n              onChange={this.onChange}\n              onSubmit={this.onSubmit}\n            />\n          }\n          sideContent={\n            <div>\n              {this.state.results && (\n                <div>\n                  {this.state.results.info.facets[\"category1\"][0].data.map(\n                    category1Facet => (\n                      <div key={category1Facet.value}>\n                        <span\n                          className=\"selectable\"\n                          onClick={e => {\n                            e.preventDefault();\n                            this.handleClickCategory1(category1Facet.value);\n                          }}\n                        >\n                          {category1Facet.value} ({category1Facet.count})\n                        </span>\n                        {this.state.category1 === category1Facet.value && (\n                          <div>\n                            {this.state.results.info.facets[\n                              \"category2\"\n                            ][0].data.map(category2Facet => (\n                              <div key={category2Facet.value}>\n                                &nbsp;&nbsp;\n                                <span\n                                  className=\"selectable\"\n                                  onClick={e => {\n                                    e.preventDefault();\n                                    this.handleClickCategory2(\n                                      category2Facet.value\n                                    );\n                                  }}\n                                >\n                                  {category2Facet.value} ({category2Facet.count}\n                                  )\n                                </span>\n                                {this.state.category2 ===\n                                  category2Facet.value && (\n                                  <div>\n                                    {this.state.results.info.facets[\n                                      \"category3\"\n                                    ][0].data.map(category3Facet => (\n                                      <div key={category3Facet.value}>\n                                        &nbsp;&nbsp;&nbsp;&nbsp;\n                                        <span\n                                          className=\"selectable\"\n                                          onClick={e => {\n                                            e.preventDefault();\n                                            this.handleClickCategory3(\n                                              category3Facet.value\n                                            );\n                                          }}\n                                        >\n                                          {category3Facet.value} (\n                                          {category3Facet.count})\n                                        </span>\n                                      </div>\n                                    ))}\n                                  </div>\n                                )}\n                              </div>\n                            ))}\n                          </div>\n                        )}\n                      </div>\n                    )\n                  )}\n                </div>\n              )}\n            </div>\n          }\n          bodyContent={\n            <div>\n              {this.state.results &&\n                this.state.results.results.map(result => (\n                  <Result\n                    key={result.getRaw(\"id\")}\n                    fields={{\n                      category1: result.getRaw(\"category1\"),\n                      category2: result.getRaw(\"category2\"),\n                      category3: result.getRaw(\"category3\")\n                    }}\n                    title={result.getRaw(\"name\")}\n                    onClickLink={() => {}}\n                  />\n                ))}\n            </div>\n          }\n        />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}